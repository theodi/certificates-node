<%- include('../../partials/header') %>
<%- include('../../partials/survey-header') %>

<section class="light-grey new-project padded">
    <style>
        .longText input {
            min-width: 80%;
        }
        .submit {
            margin-top: 2em;
        }
        .padded {
            padding: 2em;
        }
    </style>
    <div id="surveyContainer">
        <div id="sidebar" style="float: left; width: 20%; padding: 10px;">
            <!-- Sidebar will be dynamically generated -->
        </div>
        <div id="surveyElement" style="float: left; width: 50%; padding: 10px;"></div>
        <div id="certificationProgress" style="float: right; padding: 20px; border: 1px solid #ccc; background-color: #fff; width: 280px;">
            <div id="res" class="alert"></div>
            <h3>Certification Progress</h3>
            <div id="certificationProgressDetail">

            </div>
        </div>
    </div>

    <script>
        // Load DOMPurify for safe HTML rendering
        (function loadDOMPurify(){
          if (!window.DOMPurify) {
            var s = document.createElement('script');
            s.src = 'https://cdn.jsdelivr.net/npm/dompurify@2.5.6/dist/purify.min.js';
            document.head.appendChild(s);
          }
        })();

        let survey = null;
        $('#dataForm').html("");
        $('#res').html("");
        $('form').show();

        const certificationProgress = {
            levels: {}, // Dynamically populated based on the levels in the schema
        };
        // Default to English; will override if survey provides supported languages
        try { Survey.surveyLocalization.supportedLocales = ["en"]; } catch(e) {}
        let selectedLanguage = "en"; // Default to English

        document.addEventListener("DOMContentLoaded", function () {
            const responseSetId = '<%= responseSetId %>';
            const surveyId = '<%= surveyId %>';
            // Load specific survey definition
            Promise.all([
                fetch(`/surveys/${surveyId}`, { headers: { 'Accept': 'application/json' }}).then(r => r.json()),
                fetch(`/datasets/${encodeURIComponent('<%= datasetId %>')}/certificates/${responseSetId}`, { headers: { 'Accept': 'application/json' }}).then(r => r.json())
            ]).then(([schema, rs]) => {
                    survey = new Survey.Model(schema);
                    // Allow HTML in titles/descriptions when supported by SurveyJS
                    try { survey.allowHtml = true; } catch(e) {}
                    // Language selector handling (hide/disable unless survey declares supportedLanguages)
                    const langSelect = document.getElementById('languageSelector');
                    const supported = Array.isArray(schema.supportedLanguages) ? schema.supportedLanguages : null;
                    if (supported && supported.length) {
                        try { Survey.surveyLocalization.supportedLocales = supported; } catch(e) {}
                        if (langSelect) {
                            // Rebuild options based on supported list
                            langSelect.innerHTML = '';
                            supported.forEach(code => {
                                const opt = document.createElement('option');
                                opt.value = code;
                                opt.textContent = (code || '').toString().toUpperCase();
                                langSelect.appendChild(opt);
                            });
                            langSelect.disabled = false;
                            langSelect.style.display = '';
                        }
                        survey.locale = (langSelect && langSelect.value) ? langSelect.value : supported[0];
                        selectedLanguage = survey.locale;
                    } else {
                        // No supportedLanguages â†’ hide the selector and force English
                        if (langSelect) { langSelect.disabled = true; langSelect.style.display = 'none'; }
                        survey.locale = 'en';
                        selectedLanguage = 'en';
                    }

                    // Update language dynamically when the dropdown changes
                    if (langSelect && !langSelect.disabled) {
                        langSelect.addEventListener("change", function () {
                            survey.locale = langSelect.value;
                            selectedLanguage = langSelect.value;
                            const visibleQuestions = survey.getAllQuestions().filter((q) => q.isVisible);
                            const visibleSchemaQuestions = schemaQuestions.filter((schemaQuestion) =>
                                visibleQuestions.some((surveyQuestion) => surveyQuestion.name === schemaQuestion.name)
                            );
                            calculateProgress(visibleSchemaQuestions, survey.data);
                        });
                    }

                    // Disable progress bar and question numbering for custom navigation
                    survey.showProgressBar = "off";
                    survey.showQuestionNumbers = "off";

                    const schemaQuestions = getAllQuestionsFromSchema(schema);
                    // Initialize progress tracking based on schema levels
                    initializeProgress(schemaQuestions);
                    // Get all currently visible questions from the survey
                    const visibleQuestions = survey.getAllQuestions().filter((q) => q.isVisible);

                    // Filter schemaQuestions to match only visible questions by name
                    const visibleSchemaQuestions = schemaQuestions.filter((schemaQuestion) =>
                        visibleQuestions.some((surveyQuestion) => surveyQuestion.name === schemaQuestion.name)
                    );

                    // Prefill from existing responses
                    const initialData = {};
                    try {
                      if (rs && rs.responses) {
                        for (const [k, v] of Object.entries(rs.responses)) {
                          if (v && typeof v === 'object' && 'value' in v) initialData[k] = v.value;
                        }
                      }
                    } catch(_) {}
                    // Calculate progress based on visible schema questions
                    calculateProgress(visibleSchemaQuestions, initialData);

                    // Generate a sidebar for navigation
                    const sidebar = document.getElementById("sidebar");
                    schema.pages.forEach((page, index) => {
                        const pageLink = document.createElement("button");
                        pageLink.textContent = page.title.default || page.title || `Page ${index + 1}`;
                        pageLink.style.display = "block";
                        pageLink.style.marginBottom = "10px";
                        pageLink.onclick = () => {
                            survey.currentPageNo = index;
                        };
                        sidebar.appendChild(pageLink);
                    });
                    const saveQueue = new Map();
                    let saveTimer = null;
                    function scheduleSave(name, value) {
                      saveQueue.set(name, { value });
                      if (saveTimer) clearTimeout(saveTimer);
                      saveTimer = setTimeout(async () => {
                        const payload = { responses: Object.fromEntries(saveQueue.entries()) };
                        saveQueue.clear();
                      try {
                          const resp = await fetch(`/datasets/${encodeURIComponent('<%= datasetId %>')}/certificates/${responseSetId}`, {
                            method: 'PATCH',
                            headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' },
                            body: JSON.stringify(payload)
                          });
                          try {
                            const data = await resp.json();
                            if (data && data.progress) {
                              const progressContainer = document.getElementById("certificationProgressDetail");
                              if (progressContainer && data.progress.levels) {
                                // Instead of hand-rendering, re-use local renderer that includes <details>
                                try {
                                  const visibleQuestionsNow = survey.getAllQuestions().filter((q) => q.isVisible);
                                  const visibleSchemaQuestionsNow = schemaQuestions.filter((schemaQuestion) =>
                                    visibleQuestionsNow.some((surveyQuestion) => surveyQuestion.name === schemaQuestion.name)
                                  );
                                  calculateProgress(visibleSchemaQuestionsNow, survey.data);
                                } catch(_) {}
                              }
                            }
                          } catch(_) {}
                        } catch (e) {
                          console.error('Autosave failed', e);
                        }
                      }, 400);
                    }
                    survey.onValueChanged.add((sender, options) => {
                        // Get all currently visible questions from the survey
                        const visibleQuestions = survey.getAllQuestions().filter((q) => q.isVisible);

                        // Filter schemaQuestions to match only visible questions by name
                        const visibleSchemaQuestions = schemaQuestions.filter((schemaQuestion) =>
                            visibleQuestions.some((surveyQuestion) => surveyQuestion.name === schemaQuestion.name)
                        );

                        // Calculate progress based on visible schema questions
                        calculateProgress(visibleSchemaQuestions, sender.data);
                        // Tick UI immediately when a text field becomes non-empty
                        try {
                          if (options && options.name) {
                            const q = visibleQuestions.find(q => q.name === options.name);
                            const req = q && (q.requirement || null);
                            if (q && (q.getType?.() === 'text' || q.getType?.() === 'comment') && req && req.level) {
                              const val = options.value;
                              if (val != null && String(val).trim().length > 0) {
                                // Already handled by calculateProgress; no-op here
                              }
                            }
                          }
                        } catch(_) {}
                        if (options && options.name) scheduleSave(options.name, options.value);
                    });
                    survey.onComplete.add((sender, options) => {});

                    // Helper: get localized string from either plain string or { default, <lang> }
                    function localized(textOrObj) {
                        if (!textOrObj) return '';
                        if (typeof textOrObj === 'string') return textOrObj;
                        if (typeof textOrObj === 'object') {
                            return textOrObj[survey.locale] || textOrObj.default || '';
                        }
                        return '';
                    }

                    // Render overall survey title/description with HTML
                    const applySurveyHeaderHtml = (rootEl) => {
                        if (!rootEl) return;
                        const surveyTitleEl = rootEl.querySelector('.sd-title.sd-element__title, .sd-title, [data-testid="survey-title"]');
                        const surveyDescEl = rootEl.querySelector('.sd-description.sd-element__description, .sd-description, [data-testid="survey-description"]');
                        const surveyTitleHtml = localized(survey.title);
                        const surveyDescHtml = localized(survey.description);
                        if (surveyTitleEl && surveyTitleHtml && window.DOMPurify && /[<>]/.test(surveyTitleHtml)) {
                            surveyTitleEl.innerHTML = DOMPurify.sanitize(surveyTitleHtml);
                        }
                        if (surveyDescEl && surveyDescHtml && window.DOMPurify) {
                            surveyDescEl.innerHTML = DOMPurify.sanitize(surveyDescHtml);
                        }
                    };

                    if (survey.onAfterRenderSurvey && survey.onAfterRenderSurvey.add) {
                        survey.onAfterRenderSurvey.add(function(_, options) {
                            applySurveyHeaderHtml(options.htmlElement);
                        });
                    }

                    // Render page title/description with HTML
                    if (survey.onAfterRenderPage && survey.onAfterRenderPage.add) {
                        survey.onAfterRenderPage.add(function(_, options) {
                            const page = options.page;
                            const host = options.htmlElement;
                            console.log(host);
                            console.log(page);
                            if (!host || !page) return;
                            const pageDescEl = host.querySelector('.sd-page__description, .sd-description, [data-testid="page-description"]');
                            const pageTitleEl = host.querySelector('.sd-page__title, .sd-title, [data-testid=\"page-title\"]');
                            console.log(pageTitleEl);
                            const pageDescHtml = localized(page.description);
                            const pageTitleHtml = localized(page.title);
                            if (pageDescEl && pageDescHtml && window.DOMPurify) {
                                pageDescEl.innerHTML = DOMPurify.sanitize(pageDescHtml);
                            }
                            if (pageTitleEl && pageTitleHtml && window.DOMPurify && /[<>]/.test(pageTitleHtml)) {
                                pageTitleEl.innerHTML = DOMPurify.sanitize(pageTitleHtml);
                            }
                        });
                    }

                    // Render question description/title with HTML
                    survey.onAfterRenderQuestion.add(function(_, options) {
                        const q = options.question;
                        const host = options.htmlElement;
                        if (!host) return;
                        const descEl = host.querySelector('.sd-question__description, .sd-description, [data-testid="question-description"]');
                        const titleEl = host.querySelector('.sd-question__title .sv-string-viewer');
                        const descriptionHtml = localized(q.description);
                        const titleHtml = localized(q.locTitle && q.locTitle.text ? q.locTitle.text : q.title);
                        if (descEl && descriptionHtml && window.DOMPurify) {
                            descEl.innerHTML = DOMPurify.sanitize(descriptionHtml);
                        }
                        
                        if (titleEl && titleHtml && window.DOMPurify) {
                            // Only override if it contains HTML tags
                            if (/[<>]/.test(titleHtml)) {
                                titleEl.innerHTML = DOMPurify.sanitize(titleHtml);
                            }
                        }
                    });
                    // Apply initial data
                    survey.data = initialData;
                    $("#surveyElement").Survey({ model: survey });

                    // Fallback in case onAfterRenderSurvey is unavailable
                    if (!(survey.onAfterRenderSurvey && survey.onAfterRenderSurvey.add)) {
                        setTimeout(() => applySurveyHeaderHtml(document.getElementById('surveyElement')), 0);
                    }

                    // After initial render, recompute progress once visibility is fully applied
                    setTimeout(() => {
                      try {
                        const visibleQuestionsNow = survey.getAllQuestions().filter((q) => q.isVisible);
                        const visibleSchemaQuestionsNow = schemaQuestions.filter((schemaQuestion) =>
                          visibleQuestionsNow.some((surveyQuestion) => surveyQuestion.name === schemaQuestion.name)
                        );
                        calculateProgress(visibleSchemaQuestionsNow, survey.data);
                      } catch(_) {}
                    }, 0);
                });
        });

        // Helper function to extract all questions from the schema
        function getAllQuestionsFromSchema(schema) {
            const questions = [];

            // Recursive function to traverse schema
            function traverse(elements) {
                elements.forEach((element) => {
                    if (element.type === "panel" || element.type === "paneldynamic") {
                        // If it's a panel, traverse its inner elements
                        if (element.elements) {
                            traverse(element.elements);
                        }
                    } else if (element.type) {
                        // Add any other question-like element
                        questions.push(element);
                    }
                });
            }

            // Traverse all pages in the schema
            schema.pages.forEach((page) => {
                if (page.elements) {
                    traverse(page.elements);
                }
            });

            return questions;
        }
        function initializeProgress(schemaQuestions) {
            const levels = [];
            schemaQuestions.forEach((q) => {
                if (Array.isArray(q.choices)) {
                    q.choices.forEach((c) => { if (c?.requirement?.level !== undefined) levels.push(c.requirement.level); });
                }
                if (q?.requirement?.level !== undefined) levels.push(q.requirement.level);
                if (Array.isArray(q.requirements)) {
                    q.requirements.forEach(r => { if (r?.level !== undefined) levels.push(r.level); });
                }
            });
            const maxLevel = levels.length ? Math.max(...levels) : 4;
            for (let i = 1; i <= maxLevel; i++) {
                certificationProgress.levels[i] = { progress: 0, unmet: [] };
            }
        }

        function calculateProgress(schemaQuestions, data) {
    // Reset progress and unmet lists for all levels
    Object.keys(certificationProgress.levels).forEach((level) => {
        certificationProgress.levels[level].progress = 0;
        certificationProgress.levels[level].unmet = [];
    });

    // Traverse questions and data to calculate levels
    schemaQuestions.forEach((question) => {
        const answer = data[question.name];
        const requirement = question.requirement; // Access requirement from schema question

        const getProgressText = (progressText) => {
            return progressText[selectedLanguage] || progressText.default;
        };

        if (Array.isArray(question.choices)) {
            const selected = Array.isArray(answer) ? answer : (answer != null ? [answer] : []);
            // Element-level requirements array
            if (Array.isArray(question.requirements) && question.requirements.length) {
                question.requirements.forEach((req) => {
                    const level = req.level;
                    let met = false;
                    if (question.type === 'boolean') {
                        met = req.requireTrue === false ? (answer !== undefined && answer !== null) : (answer === true);
                    } else {
                        met = (selected.length > 0 || (answer != null && String(answer).trim().length > 0));
                    }
                    if (met) {
                        for (let i = 1; i <= level; i++) certificationProgress.levels[i].progress++;
                    } else {
                        certificationProgress.levels[level].unmet.push({ text: getProgressText(req.progressText), questionName: question.name });
                    }
                });
            } else if (question.requirement) {
                const level = question.requirement.level;
                const met = (selected.length > 0);
                if (met) {
                    for (let i = 1; i <= level; i++) certificationProgress.levels[i].progress++;
                } else {
                    certificationProgress.levels[level].unmet.push({ text: getProgressText(question.requirement.progressText), questionName: question.name });
                }
            }

            // Choice-level requirements
            const isSingle = (question.type === 'radiogroup');
            if (isSingle) {
                // For single-choice, only the selected choice counts; non-selected should NOT be unmet
                const selectedValue = selected[0];
                const selectedChoice = question.choices.find(c => c && c.value === selectedValue);
                if (selectedChoice && selectedChoice.requirement && selectedChoice.requirement.level) {
                    const level = selectedChoice.requirement.level;
                    for (let i = 1; i <= level; i++) certificationProgress.levels[i].progress++;
                }
                // If some choices have requirements but the selected choice does NOT, then the highest
                // achievable level for this question is one less than the minimum level of the other choices.
                const choiceLevels = question.choices
                  .filter(c => c && c.requirement && typeof c.requirement.level !== 'undefined')
                  .map(c => c.requirement.level);
                if (choiceLevels.length) {
                  const selectedHasReq = !!(selectedChoice && selectedChoice.requirement && typeof selectedChoice.requirement.level !== 'undefined');
                  if (!selectedHasReq) {
                    const minLevel = Math.min(...choiceLevels);
                    // Find any choice at minLevel to get its requirement text
                    const minChoice = question.choices.find(c => c && c.requirement && c.requirement.level === minLevel);
                    const reqText = minChoice && minChoice.requirement && minChoice.requirement.progressText
                      ? getProgressText(minChoice.requirement.progressText)
                      : 'Requirement not met for this level';
                    if (certificationProgress.levels[minLevel]) {
                      certificationProgress.levels[minLevel].unmet.push({
                        text: reqText,
                        questionName: question.name
                      });
                    }
                  }
                }
            } else {
                // For multi-select, each selected choice contributes positively; ignore non-selected
                question.choices.forEach((choice) => {
                    if (!choice?.requirement?.level) return;
                    const level = choice.requirement.level;
                    const isSelected = selected.includes(choice.value);
                    if (isSelected) {
                        for (let i = 1; i <= level; i++) certificationProgress.levels[i].progress++;
                    }
                });
            }
        } else if (question.type === "boolean" || question.type === "text") {
            if (requirement?.level) {
                const level = requirement.level;
                let isMet = false;
                if (question.type === 'boolean') {
                    // For boolean, default requireTrue=true unless explicitly false
                    if (requirement.requireTrue === false) {
                        isMet = (answer !== undefined && answer !== null);
                    } else {
                        isMet = (answer === true);
                    }
                } else {
                    // For text-like answers, consider non-empty value as met
                    isMet = (answer !== null && answer !== undefined && String(answer).trim().length > 0);
                }

                if (isMet) {
                    for (let i = 1; i <= level; i++) {
                        certificationProgress.levels[i].progress++;
                    }
                } else {
                    certificationProgress.levels[level].unmet.push({
                        text: getProgressText(requirement.progressText),
                        questionName: question.name
                    });
                }
            } else if (Array.isArray(question.requirements) && question.requirements.length) {
                question.requirements.forEach((req) => {
                    const level = req.level;
                    let met = false;
                    if (question.type === 'boolean') {
                        met = req.requireTrue === false ? (answer !== undefined && answer !== null) : (answer === true);
                    } else {
                        met = (answer !== null && answer !== undefined && String(answer).trim().length > 0);
                    }
                    if (met) {
                        for (let i = 1; i <= level; i++) certificationProgress.levels[i].progress++;
                    } else {
                        certificationProgress.levels[level].unmet.push({ text: getProgressText(req.progressText), questionName: question.name });
                    }
                });
            }
        }
    });

    console.log("Certification Progress:", certificationProgress);
    updateProgressUI();
}

function updateProgressUI() {
    const progressContainer = document.getElementById("certificationProgressDetail");
    progressContainer.innerHTML = ""; // Clear previous progress

    Object.keys(certificationProgress.levels).filter((lvl) => Number(lvl) > 0).forEach((level) => {
        const { progress, unmet } = certificationProgress.levels[level];

        // Deduplicate unmet by questionName+text to avoid duplicates when multiple answers map to same level
        const uniqueUnmet = [];
        const seen = new Set();
        (unmet || []).forEach((req) => {
            const key = `${req.questionName}::${req.text}`;
            if (!seen.has(key)) { seen.add(key); uniqueUnmet.push(req); }
        });

        const totalRequirements = progress + uniqueUnmet.length;
        const progressPercentage = totalRequirements > 0 ? (progress / totalRequirements) * 100 : 0;

        const unmetDropdown = uniqueUnmet.length
            ? `
            <details>
                <summary>${uniqueUnmet.length} unmet requirements</summary>
                <div class="dropdown-content">
                    <ul>
                        ${uniqueUnmet
                            .map(
                                (req) =>
                                    `<li><a href="#" class="navigate-to-question" data-question-name="${req.questionName}">${req.text}</a></li>`
                            )
                            .join("")}
                    </ul>
                </div>
            </details>
            `
            : `<p>All requirements met for this level.</p>`;

        progressContainer.insertAdjacentHTML(
            "beforeend",
            `
            <div style="margin-bottom: 20px; border: 1px solid #ddd; padding: 10px; border-radius: 8px;">
                <h4>Level ${level}</h4>
                <div style="position: relative; background-color: #f3f3f3; height: 20px; width: 100%; border-radius: 10px;">
                    <div style="width: ${progressPercentage}%; background-color: #4caf50; height: 100%; border-radius: 10px;">
                    </div>
                </div>
                <p>${progress} out of ${totalRequirements} requirements met (${Math.round(progressPercentage)}%)</p>
                ${unmetDropdown}
            </div>
            `
        );
    });

    // Add click handlers to navigate to questions
    document.querySelectorAll(".navigate-to-question").forEach((link) => {
        link.addEventListener("click", (event) => {
            event.preventDefault();
            const questionName = event.target.getAttribute("data-question-name");
            navigateToQuestion(questionName);
        });
    });
}

function navigateToQuestion(questionName) {
    const question = survey.getQuestionByName(questionName);

    if (question) {
        const pageIndex = survey.pages.indexOf(question.page); // Get the page containing the question
        survey.currentPageNo = pageIndex; // Navigate to the page
        const questionElement = document.querySelector(`[data-name="${questionName}"]`);
        if (questionElement) {
            questionElement.scrollIntoView({ behavior: "smooth", block: "center" }); // Scroll to the question
        }
    }
}


    </script>
</section>
<%- include('../../partials/footer') %>