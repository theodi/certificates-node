<%- include('../partials/header') %>
<%- include('./survey-header') %>

<section class="light-grey new-project padded">
    <style>
        .longText input {
            min-width: 80%;
        }
        .submit {
            margin-top: 2em;
        }
        .padded {
            padding: 2em;
        }
    </style>
    <div id="surveyContainer">
        <div id="sidebar" style="float: left; width: 20%; padding: 10px;">
            <!-- Sidebar will be dynamically generated -->
        </div>
        <div id="surveyElement" style="float: left; width: 50%; padding: 10px;"></div>
        <div id="certificationProgress" style="float: right; padding: 20px; border: 1px solid #ccc; background-color: #fff; width: 280px;">
            <div id="res" class="alert"></div>
            <h3>Certification Progress</h3>
            <div id="certificationProgressDetail">

            </div>
        </div>
    </div>

    <script>
        // Load DOMPurify for safe HTML rendering
        (function loadDOMPurify(){
          if (!window.DOMPurify) {
            var s = document.createElement('script');
            s.src = 'https://cdn.jsdelivr.net/npm/dompurify@2.5.6/dist/purify.min.js';
            document.head.appendChild(s);
          }
        })();

        let survey = null;
        $('#dataForm').html("");
        $('#res').html("");
        $('form').show();

        const certificationProgress = {
            levels: {}, // Dynamically populated based on the levels in the schema
        };
        Survey.surveyLocalization.supportedLocales = ["en", "es"];
        let selectedLanguage = "en"; // Default to English

        document.addEventListener("DOMContentLoaded", function () {
            // Fetch the client schema and update the "authority" enum with authority names and ids
            fetch('/data/survey')
                .then(response => response.json())
                .then(schema => {
                    survey = new Survey.Model(schema);
                    // Allow HTML in titles/descriptions when supported by SurveyJS
                    try { survey.allowHtml = true; } catch(e) {}
                    // Set initial language from the dropdown
                    survey.locale = languageSelector.value;

                    // Update language dynamically when the dropdown changes
                    languageSelector.addEventListener("change", function () {
                        survey.locale = languageSelector.value;
                        selectedLanguage = languageSelector.value; // Default to English
                        const visibleQuestions = survey.getAllQuestions().filter((q) => q.isVisible);

                        // Filter schemaQuestions to match only visible questions by name
                        const visibleSchemaQuestions = schemaQuestions.filter((schemaQuestion) =>
                            visibleQuestions.some((surveyQuestion) => surveyQuestion.name === schemaQuestion.name)
                        );
                        calculateProgress(visibleSchemaQuestions, survey.data);
                    });

                    // Disable progress bar and question numbering for custom navigation
                    survey.showProgressBar = "off";
                    survey.showQuestionNumbers = "off";

                    const schemaQuestions = getAllQuestionsFromSchema(schema);
                    // Initialize progress tracking based on schema levels
                    initializeProgress(schemaQuestions);
                    // Get all currently visible questions from the survey
                    const visibleQuestions = survey.getAllQuestions().filter((q) => q.isVisible);

                    // Filter schemaQuestions to match only visible questions by name
                    const visibleSchemaQuestions = schemaQuestions.filter((schemaQuestion) =>
                        visibleQuestions.some((surveyQuestion) => surveyQuestion.name === schemaQuestion.name)
                    );

                    // Calculate progress based on visible schema questions
                    calculateProgress(visibleSchemaQuestions, {});

                    // Generate a sidebar for navigation
                    const sidebar = document.getElementById("sidebar");
                    schema.pages.forEach((page, index) => {
                        const pageLink = document.createElement("button");
                        pageLink.textContent = page.title.default || page.title || `Page ${index + 1}`;
                        pageLink.style.display = "block";
                        pageLink.style.marginBottom = "10px";
                        pageLink.onclick = () => {
                            survey.currentPageNo = index;
                        };
                        sidebar.appendChild(pageLink);
                    });
                    survey.onValueChanged.add((sender, options) => {
                        // Get all currently visible questions from the survey
                        const visibleQuestions = survey.getAllQuestions().filter((q) => q.isVisible);

                        // Filter schemaQuestions to match only visible questions by name
                        const visibleSchemaQuestions = schemaQuestions.filter((schemaQuestion) =>
                            visibleQuestions.some((surveyQuestion) => surveyQuestion.name === schemaQuestion.name)
                        );

                        // Calculate progress based on visible schema questions
                        calculateProgress(visibleSchemaQuestions, sender.data);
                        console.log(JSON.stringify(sender.data, null, 3))
                    });
                    survey.onComplete.add((sender, options) => {
                        console.log(JSON.stringify(sender.data, null, 3));
                    });

                    // Helper: get localized string from either plain string or { default, <lang> }
                    function localized(textOrObj) {
                        if (!textOrObj) return '';
                        if (typeof textOrObj === 'string') return textOrObj;
                        if (typeof textOrObj === 'object') {
                            return textOrObj[survey.locale] || textOrObj.default || '';
                        }
                        return '';
                    }

                    // Render overall survey title/description with HTML
                    const applySurveyHeaderHtml = (rootEl) => {
                        if (!rootEl) return;
                        const surveyTitleEl = rootEl.querySelector('.sd-title.sd-element__title, .sd-title, [data-testid="survey-title"]');
                        const surveyDescEl = rootEl.querySelector('.sd-description.sd-element__description, .sd-description, [data-testid="survey-description"]');
                        const surveyTitleHtml = localized(survey.title);
                        const surveyDescHtml = localized(survey.description);
                        if (surveyTitleEl && surveyTitleHtml && window.DOMPurify && /[<>]/.test(surveyTitleHtml)) {
                            surveyTitleEl.innerHTML = DOMPurify.sanitize(surveyTitleHtml);
                        }
                        if (surveyDescEl && surveyDescHtml && window.DOMPurify) {
                            surveyDescEl.innerHTML = DOMPurify.sanitize(surveyDescHtml);
                        }
                    };

                    if (survey.onAfterRenderSurvey && survey.onAfterRenderSurvey.add) {
                        survey.onAfterRenderSurvey.add(function(_, options) {
                            applySurveyHeaderHtml(options.htmlElement);
                        });
                    }

                    // Render page title/description with HTML
                    if (survey.onAfterRenderPage && survey.onAfterRenderPage.add) {
                        survey.onAfterRenderPage.add(function(_, options) {
                            const page = options.page;
                            const host = options.htmlElement;
                            console.log(host);
                            console.log(page);
                            if (!host || !page) return;
                            const pageDescEl = host.querySelector('.sd-page__description, .sd-description, [data-testid="page-description"]');
                            const pageTitleEl = host.querySelector('.sd-page__title, .sd-title, [data-testid=\"page-title\"]');
                            console.log(pageTitleEl);
                            const pageDescHtml = localized(page.description);
                            const pageTitleHtml = localized(page.title);
                            if (pageDescEl && pageDescHtml && window.DOMPurify) {
                                pageDescEl.innerHTML = DOMPurify.sanitize(pageDescHtml);
                            }
                            if (pageTitleEl && pageTitleHtml && window.DOMPurify && /[<>]/.test(pageTitleHtml)) {
                                pageTitleEl.innerHTML = DOMPurify.sanitize(pageTitleHtml);
                            }
                        });
                    }

                    // Render question description/title with HTML
                    survey.onAfterRenderQuestion.add(function(_, options) {
                        const q = options.question;
                        const host = options.htmlElement;
                        if (!host) return;
                        const descEl = host.querySelector('.sd-question__description, .sd-description, [data-testid="question-description"]');
                        const titleEl = host.querySelector('.sd-question__title, .sd-title, [data-testid="question-title"]');
                        const descriptionHtml = localized(q.description);
                        const titleHtml = localized(q.locTitle && q.locTitle.text ? q.locTitle.text : q.title);
                        if (descEl && descriptionHtml && window.DOMPurify) {
                            descEl.innerHTML = DOMPurify.sanitize(descriptionHtml);
                        }
                        if (titleEl && titleHtml && window.DOMPurify) {
                            // Only override if it contains HTML tags
                            if (/[<>]/.test(titleHtml)) {
                                titleEl.innerHTML = DOMPurify.sanitize(titleHtml);
                            }
                        }
                    });
                    $("#surveyElement").Survey({ model: survey });

                    // Fallback in case onAfterRenderSurvey is unavailable
                    if (!(survey.onAfterRenderSurvey && survey.onAfterRenderSurvey.add)) {
                        setTimeout(() => applySurveyHeaderHtml(document.getElementById('surveyElement')), 0);
                    }
                });
        });

        // Helper function to extract all questions from the schema
        function getAllQuestionsFromSchema(schema) {
            const questions = [];

            // Recursive function to traverse schema
            function traverse(elements) {
                elements.forEach((element) => {
                    if (element.type === "panel" || element.type === "paneldynamic") {
                        // If it's a panel, traverse its inner elements
                        if (element.elements) {
                            traverse(element.elements);
                        }
                    } else if (element.type) {
                        // Add any other question-like element
                        questions.push(element);
                    }
                });
            }

            // Traverse all pages in the schema
            schema.pages.forEach((page) => {
                if (page.elements) {
                    traverse(page.elements);
                }
            });

            return questions;
        }
        function initializeProgress(schemaQuestions) {
            const maxLevel = Math.max(
                ...schemaQuestions
                    .flatMap((q) => q.choices?.map((c) => c.requirement?.level) || [q.requirement?.level])
                    .filter((level) => level !== undefined)
            );

            for (let i = 1; i <= maxLevel; i++) {
                certificationProgress.levels[i] = { progress: 0, unmet: [] };
            }
        }

        function calculateProgress(schemaQuestions, data) {
    // Reset progress and unmet lists for all levels
    Object.keys(certificationProgress.levels).forEach((level) => {
        certificationProgress.levels[level].progress = 0;
        certificationProgress.levels[level].unmet = [];
    });

    // Traverse questions and data to calculate levels
    schemaQuestions.forEach((question) => {
        const answer = data[question.name];
        const requirement = question.requirement; // Access requirement from schema question

        const getProgressText = (progressText) => {
            return progressText[selectedLanguage] || progressText.default;
        };

        if (question.choices) {
            // Handle choice-based questions
            if (answer) {
                const selectedChoice = question.choices.find((choice) => choice.value === answer);
                if (selectedChoice?.requirement?.level) {
                    const level = selectedChoice.requirement.level;

                    // Increment progress for this and all lower levels
                    for (let i = 1; i <= level; i++) {
                        certificationProgress.levels[i].progress++;
                    }
                } else if (question.requirement) {
                    certificationProgress.levels[question.requirement.level].progress++;
                }
            } else {
                let flag = false;
                // Add unmet requirements for unanswered choice-based questions
                question.choices.forEach((choice) => {
                    if (choice.requirement?.level) {
                        flag = true;
                        const level = choice.requirement.level;
                        certificationProgress.levels[level].unmet.push({
                            text: getProgressText(choice.requirement.progressText),
                            questionName: question.name
                        });
                    }
                });
                if (!flag && question.requirement) {
                    const level = question.requirement.level;
                    certificationProgress.levels[level].unmet.push({
                        text: getProgressText(question.requirement.progressText),
                        questionName: question.name
                    });
                }
            }
        } else if (question.type === "boolean" || question.type === "text") {
            if (requirement?.level) {
                const level = requirement.level;
                const isMet = requirement.requireTrue === false ? answer !== undefined : answer === true;

                if (isMet) {
                    for (let i = 1; i <= level; i++) {
                        certificationProgress.levels[i].progress++;
                    }
                } else {
                    certificationProgress.levels[level].unmet.push({
                        text: getProgressText(requirement.progressText),
                        questionName: question.name
                    });
                }
            }
        }
    });

    console.log("Certification Progress:", certificationProgress);
    updateProgressUI();
}

function updateProgressUI() {
    const progressContainer = document.getElementById("certificationProgressDetail");
    progressContainer.innerHTML = ""; // Clear previous progress

    Object.keys(certificationProgress.levels).forEach((level) => {
        const { progress, unmet } = certificationProgress.levels[level];

        const totalRequirements = progress + unmet.length;
        const progressPercentage = totalRequirements > 0 ? (progress / totalRequirements) * 100 : 0;

        const unmetDropdown = unmet.length
            ? `
            <details>
                <summary>${unmet.length} unmet requirements</summary>
                <div class="dropdown-content">
                    <ul>
                        ${unmet
                            .map(
                                (req) =>
                                    `<li><a href="#" class="navigate-to-question" data-question-name="${req.questionName}">${req.text}</a></li>`
                            )
                            .join("")}
                    </ul>
                </div>
            </details>
            `
            : `<p>All requirements met for this level.</p>`;

        progressContainer.insertAdjacentHTML(
            "beforeend",
            `
            <div style="margin-bottom: 20px; border: 1px solid #ddd; padding: 10px; border-radius: 8px;">
                <h4>Level ${level}</h4>
                <div style="position: relative; background-color: #f3f3f3; height: 20px; width: 100%; border-radius: 10px;">
                    <div style="width: ${progressPercentage}%; background-color: #4caf50; height: 100%; border-radius: 10px;">
                    </div>
                </div>
                <p>${progress} out of ${totalRequirements} requirements met (${Math.round(progressPercentage)}%)</p>
                ${unmetDropdown}
            </div>
            `
        );
    });

    // Add click handlers to navigate to questions
    document.querySelectorAll(".navigate-to-question").forEach((link) => {
        link.addEventListener("click", (event) => {
            event.preventDefault();
            const questionName = event.target.getAttribute("data-question-name");
            navigateToQuestion(questionName);
        });
    });
}

function navigateToQuestion(questionName) {
    const question = survey.getQuestionByName(questionName);

    if (question) {
        const pageIndex = survey.pages.indexOf(question.page); // Get the page containing the question
        survey.currentPageNo = pageIndex; // Navigate to the page
        const questionElement = document.querySelector(`[data-name="${questionName}"]`);
        if (questionElement) {
            questionElement.scrollIntoView({ behavior: "smooth", block: "center" }); // Scroll to the question
        }
    }
}


    </script>
</section>
<%- include('../partials/footer') %>